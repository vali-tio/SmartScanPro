<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SmartScan Lite ‚Äî High Quality</title>
 <link rel="manifest" href="manifest.webmanifest">
  <style>
  :root { --bg:#090d12; --card:#101722; --muted:#9fb0c3; --text:#e7edf4; --accent:#53b1ff; --ok:#22c55e; --warn:#f59e0b; }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; background:linear-gradient(180deg,#0a0f15,#0d1420); color:var(--text); }
  header { position:sticky; top:0; z-index:10; backdrop-filter: blur(10px); background:rgba(9,13,18,.6); border-bottom:1px solid #1c2635; }
  .wrap { max-width:980px; margin:0 auto; padding:12px 16px; }
  h1 { font-size:20px; margin:8px 0; display:flex; align-items:center; gap:10px; }
  .badge { font-size:12px; padding:3px 8px; border-radius:999px; background:#0f2540; color:#c9e7ff; border:1px solid #2c568b; }
  .grid { display:grid; grid-template-columns:1fr; gap:12px; }
  @media(min-width:920px){ .grid{ grid-template-columns: 1.3fr .9fr; } }
  .card { background: linear-gradient(180deg, #101722, #0f1521); border:1px solid #1e2a3b; border-radius:16px; padding:12px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
  .toolbar { display:flex; flex-wrap:wrap; gap:8px; }
  button, .btn { background:#172234; color:var(--text); border:1px solid #283447; padding:10px 12px; border-radius:12px; font-weight:600; cursor:pointer; }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .btn-accent { background:#16314d; border-color:#2b5582; }
  .btn-ok { background:#12351f; border-color:#1f6b3a; }
  .btn-warn { background:#3b2b0c; border-color:#6b4e16; }
  .btn-ghost { background:transparent; border-color:#243246; }
  input[type="file"]{ display:none; }
  label.file { display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
  .small { font-size:12px; color:var(--muted); }
  .canvas-wrap { position:relative; width:100%; background:#0a0f15; border-radius:12px; overflow:hidden; border:1px dashed #2a3a51; min-height:240px; display:flex; align-items:center; justify-content:center; }
  canvas { max-width:100%; height:auto; }
  .crop-rect { position:absolute; border:2px dashed #53b1ff; pointer-events:none; }
  .handle { position:absolute; width:18px; height:18px; border-radius:50%; background:#53b1ff; border:2px solid #0b0f14; transform:translate(-50%,-50%); touch-action:none; }
  .row { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .pages { display:flex; gap:8px; flex-wrap:wrap; }
  .thumb { width:68px; height:96px; border:1px solid #223047; border-radius:10px; overflow:hidden; position:relative; }
  .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }
  .thumb .x { position:absolute; top:4px; right:4px; background:rgba(0,0,0,.6); border:1px solid #405470; border-radius:8px; font-size:12px; padding:2px 6px; cursor:pointer; }
  .seg { height:1px; background:#1f2a37; margin:8px 0; }
  .select, .num { background:#111827; color:var(--text); border:1px solid #253245; padding:8px 10px; border-radius:10px; }
  .num { width:90px; }
  footer { text-align:center; color:#8ea1b4; font-size:12px; padding:12px; }
  .chip { background:#0f2338; border:1px solid #274664; color:#cfe7ff; padding:6px 10px; border-radius:999px; font-size:12px; }
</style>
</head>
<footer id="donateFooter">
  <span>Gratis untuk semua</span>
  <a href="https://saweria.co/valitio" target="_blank" rel="noopener noreferrer">
    üíù Dukung via Saweria
  </a>
</footer>

<style>
  #donateFooter {
    position: fixed;
    bottom: 0; left: 0;
    width: 100%;
    background: var(--card);
    border-top: 1px solid var(--border);
    color: var(--text);
    font-size: 0.9rem;
    text-align: center;
    padding: 10px;
    display: flex;
    justify-content: center;
    gap: 10px;
    z-index: 999;
  }
  #donateFooter a {
    color: #f97316;
    font-weight: 600;
    text-decoration: none;
  }
  #donateFooter a:hover {
    text-decoration: underline;
  }
</style>

<body>
<header>
  <div class="wrap">
    <h1>SmartScan Lite <span class="badge">High Quality</span></h1>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <section class="card">
      <div class="toolbar">
        <label class="file btn btn-accent">
          <input id="fileInput" type="file" accept="image/*" capture="environment" />
          üì∑ Ambil Foto / Pilih Gambar
        </label>
        <button class="btn btn-ghost" id="rotateBtn" disabled>‚Üª Putar</button>
        <select id="filterSelect" class="select" disabled>
          <option value="none">Filter: Original</option>
          <option value="gray">Grayscale</option>
          <option value="bw">Hitam-Putih (Teks)</option>
          <option value="enhance">Enhance (Kontras+)</option>
          <option value="sharpen">Sharpen (Tajamkan)</option>
        </select>
        <select id="qualityMode" class="select" title="Mode Kualitas" disabled>
          <option value="normal">Mode: Normal</option>
          <option value="hq" selected>Mode: High Quality</option>
        </select>
        <label class="chip">Max Lebar:
          <input id="maxWidth" class="num" type="number" min="800" max="4000" step="100" value="2200" disabled />
        </label>
        <label class="chip">JPG Quality:
          <input id="jpgQuality" class="num" type="number" min="0.5" max="1" step="0.05" value="1" disabled />
        </label>
        <button class="btn" id="resetBtn" disabled>Reset</button>
      </div>

      <div class="seg"></div>
      <div class="canvas-wrap">
        <canvas id="canvas"></canvas>
        <div id="cropRect" class="crop-rect" hidden></div>
        <div class="handle" id="h-tl" hidden></div>
        <div class="handle" id="h-tr" hidden></div>
        <div class="handle" id="h-bl" hidden></div>
        <div class="handle" id="h-br" hidden></div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn btn-ok" id="addPageBtn" disabled>+ Tambah ke Dokumen</button>
        <button class="btn btn-warn" id="clearPageBtn" disabled>Hapus Semua</button>
        <span class="small" id="hint">Tips: Seret 4 titik biru untuk crop dokumen.</span>
      </div>
    </section>

    <aside class="card">
      <div class="row">
        <strong>Halaman ( <span id="pageCount">0</span> )</strong>
      </div>
      <div class="pages" id="pages"></div>
      <div class="seg"></div>
      <div class="row">
        <button class="btn btn-ok" id="exportPdfBtn" disabled>‚¨áÔ∏è Export PDF (A4)</button>
        <button class="btn" id="exportJpgBtn" disabled>‚¨áÔ∏è Simpan JPG</button>
        <button class="btn" id="shareBtn" disabled>üì§ Share</button>
      </div>
      <p class="small">Mode High Quality menghasilkan gambar tajam tanpa watermark. Ukuran file bisa lebih besar.</p>
    </aside>
  </div>
</main>

<footer>
  SmartScan Lite ‚Äì semua proses lokal di perangkat Anda. Mode HQ cocok untuk cap/tanda tangan.
</footer>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const fileInput = $('#fileInput');
  const canvas = $('#canvas');
  const ctx = canvas.getContext('2d');
  const rotateBtn = $('#rotateBtn');
  const resetBtn = $('#resetBtn');
  const filterSelect = $('#filterSelect');
  const qualityMode = $('#qualityMode');
  const maxWidthInput = $('#maxWidth');
  const jpgQualityInput = $('#jpgQuality');
  const addPageBtn = $('#addPageBtn');
  const clearPageBtn = $('#clearPageBtn');
  const exportPdfBtn = $('#exportPdfBtn');
  const exportJpgBtn = $('#exportJpgBtn');
  const shareBtn = $('#shareBtn');
  const pagesWrap = $('#pages');
  const pageCount = $('#pageCount');
  const hint = $('#hint');
  const cropRect = $('#cropRect');
  const handles = { tl: $('#h-tl'), tr: $('#h-tr'), bl: $('#h-bl'), br: $('#h-br') };

  let img = new Image();
  let imgRotation = 0;
  let crop = null;
  let currentFilter = 'none';
  let quality = 1.0;
  let modeHQ = true;
  let maxWSetting = 2200;
  const pages = [];

  function setUIEnabled(hasImage){
    [rotateBtn, resetBtn, filterSelect, addPageBtn, exportJpgBtn, shareBtn, qualityMode, maxWidthInput, jpgQualityInput].forEach(el=>el.disabled = !hasImage);
    toggleCropUI(hasImage);
  }

  function toggleCropUI(show){
    [cropRect, handles.tl, handles.tr, handles.bl, handles.br].forEach(el=>{ el.hidden = !show; });
  }

  function loadImageFromFile(file){
    const reader = new FileReader();
    reader.onload = e => {
      img = new Image();
      img.onload = () => {
        imgRotation = 0;
        currentFilter = 'none';
        modeHQ = true;
        quality = 1.0;
        maxWSetting = parseInt(maxWidthInput.value) || 2200;
        drawImageFit();
        initCrop();
        setUIEnabled(true);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }
  fileInput.addEventListener('change', e => {
    const file = e.target.files?.[0];
    if (file) loadImageFromFile(file);
  });

  function drawImageFit(){
    // Determine target canvas width based on mode
    const naturalW = (imgRotation % 180 === 0) ? img.width : img.height;
    const naturalH = (imgRotation % 180 === 0) ? img.height : img.width;
    const container = canvas.parentElement.getBoundingClientRect();
    // On HQ: use min(natural, maxWSetting), on normal: min(container.width, 1200)
    const targetW = modeHQ ? Math.min(naturalW, maxWSetting) : Math.min(container.width, 1000);
    const targetH = Math.round(targetW * (naturalH / naturalW));
    canvas.width = Math.max(800, Math.floor(targetW));
    canvas.height = Math.max(800 * (naturalH/naturalW) | 0, Math.floor(targetH));

    // Draw with rotation on an offscreen canvas at same output size
    const off = document.createElement('canvas');
    off.width = canvas.width;
    off.height = canvas.height;
    const octx = off.getContext('2d');

    // Draw original image into an intermediate canvas that matches aspect
    const base = document.createElement('canvas');
    base.width = (imgRotation % 180 === 0) ? img.width : img.height;
    base.height = (imgRotation % 180 === 0) ? img.height : img.width;
    const bctx = base.getContext('2d');
    // rotate draw
    bctx.save();
    if (imgRotation === 90){ bctx.translate(base.width,0); bctx.rotate(Math.PI/2); bctx.drawImage(img,0,0); }
    else if (imgRotation === 180){ bctx.translate(base.width,base.height); bctx.rotate(Math.PI); bctx.drawImage(img,0,0); }
    else if (imgRotation === 270){ bctx.translate(0,base.height); bctx.rotate(3*Math.PI/2); bctx.drawImage(img,0,0); }
    else { bctx.drawImage(img,0,0); }
    bctx.restore();

    // scale to output
    octx.drawImage(base, 0, 0, base.width, base.height, 0, 0, off.width, off.height);

    // Blit to main canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(off,0,0);
    applyFilter(); // apply selected filter
    updateCropUI();
  }

  rotateBtn.addEventListener('click', () => { imgRotation = (imgRotation + 90) % 360; drawImageFit(); });
  resetBtn.addEventListener('click', () => { currentFilter='none'; filterSelect.value='none'; drawImageFit(); initCrop(); });
  filterSelect.addEventListener('change', e => { currentFilter = e.target.value; applyFilter(); });
  qualityMode.addEventListener('change', e => { modeHQ = (e.target.value === 'hq'); drawImageFit(); });
  maxWidthInput.addEventListener('change', e => { maxWSetting = Math.max(800, Math.min(4000, parseInt(e.target.value)||2200)); drawImageFit(); });
  jpgQualityInput.addEventListener('change', e => { quality = Math.max(0.5, Math.min(1.0, parseFloat(e.target.value)||1.0)); });

  function initCrop(){
    crop = { x: canvas.width*0.05, y: canvas.height*0.05, w: canvas.width*0.9, h: canvas.height*0.9 };
    updateCropUI();
  }

  function updateCropUI(){
    if (!crop) return;
    const wrap = canvas.getBoundingClientRect();
    const scaleX = wrap.width / canvas.width;
    const scaleY = wrap.height / canvas.height;
    const left = wrap.left + crop.x * scaleX;
    const top = wrap.top + crop.y * scaleY;
    const width = crop.w * scaleX;
    const height = crop.h * scaleY;

    cropRect.style.left = `${left}px`; cropRect.style.top = `${top}px`;
    cropRect.style.width = `${width}px`; cropRect.style.height = `${height}px`;

    handles.tl.style.left = `${left}px`; handles.tl.style.top = `${top}px`;
    handles.tr.style.left = `${left+width}px`; handles.tr.style.top = `${top}px`;
    handles.bl.style.left = `${left}px`; handles.bl.style.top = `${top+height}px`;
    handles.br.style.left = `${left+width}px`; handles.br.style.top = `${top+height}px`;
  }

  // Crop handle drag
  let dragging = null;
  Object.entries(handles).forEach(([key, el]) => {
    const start = (cx, cy) => { dragging = { key, startX: cx, startY: cy, orig: {...crop} }; };
    const move = (cx, cy) => {
      if (!dragging) return;
      const wrap = canvas.getBoundingClientRect();
      const scaleX = canvas.width / wrap.width;
      const scaleY = canvas.height / wrap.height;
      const dx = (cx - dragging.startX) * scaleX;
      const dy = (cy - dragging.startY) * scaleY;
      const minSize = 60;
      const o = dragging.orig;
      if (dragging.key === 'tl'){ crop.x = Math.min(o.x+dx, o.x+o.w-minSize); crop.y = Math.min(o.y+dy, o.y+o.h-minSize); crop.w = o.w - (crop.x - o.x); crop.h = o.h - (crop.y - o.y); }
      if (dragging.key === 'tr'){ crop.y = Math.min(o.y+dy, o.y+o.h-minSize); crop.w = Math.max(minSize, o.w + dx); crop.h = o.h - (crop.y - o.y); }
      if (dragging.key === 'bl'){ crop.x = Math.min(o.x+dx, o.x+o.w-minSize); crop.w = o.w - (crop.x - o.x); crop.h = Math.max(minSize, o.h + dy); }
      if (dragging.key === 'br'){ crop.w = Math.max(minSize, o.w + dx); crop.h = Math.max(minSize, o.h + dy); }
      crop.x = Math.max(0, Math.min(crop.x, canvas.width - crop.w));
      crop.y = Math.max(0, Math.min(crop.y, canvas.height - crop.h));
      updateCropUI();
    };
    const end = () => dragging = null;

    el.addEventListener('mousedown', e => { e.preventDefault(); start(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
    window.addEventListener('mouseup', end);

    el.addEventListener('touchstart', e => { e.preventDefault(); const t=e.touches[0]; start(t.clientX, t.clientY); }, {passive:false});
    window.addEventListener('touchmove', e => { const t=e.touches[0]; move(t.clientX, t.clientY); }, {passive:false});
    window.addEventListener('touchend', end);
  });

  function applyFilter(){
    if (!canvas.width) return;
    const temp = document.createElement('canvas');
    temp.width = canvas.width; temp.height = canvas.height;
    const tctx = temp.getContext('2d');
    tctx.drawImage(canvas, 0, 0);

    let imageData = tctx.getImageData(0,0,temp.width,temp.height);
    let d = imageData.data;

    if (currentFilter === 'gray' || currentFilter === 'bw' || currentFilter === 'enhance'){
      let contrast = 1, brightness = 0; let bw = false;
      if (currentFilter === 'gray'){ contrast = 1.0; brightness = 0; }
      if (currentFilter === 'bw'){ contrast = 1.45; brightness = 12; bw = true; }
      if (currentFilter === 'enhance'){ contrast = 1.28; brightness = 10; }

      const factor = (259*(contrast*255 + 255)) / (255*(259 - contrast*255));
      for (let i=0; i<d.length; i+=4){
        let r=d[i], g=d[i+1], b=d[i+2];
        let y = 0.299*r + 0.587*g + 0.114*b;
        if (currentFilter !== 'enhance'){ r = g = b = y; } // keep color for enhance
        r = factor*(r-128)+128 + brightness;
        g = factor*(g-128)+128 + brightness;
        b = factor*(b-128)+128 + brightness;
        if (bw){
          const t = 180;
          const v = (0.2126*r + 0.7152*g + 0.0722*b) >= t ? 255 : 0;
          d[i]=d[i+1]=d[i+2]=v;
        } else {
          d[i]=Math.max(0,Math.min(255,r));
          d[i+1]=Math.max(0,Math.min(255,g));
          d[i+2]=Math.max(0,Math.min(255,b));
        }
      }
      tctx.putImageData(imageData,0,0);
    }

    if (currentFilter === 'sharpen'){
      // Simple unsharp mask: blur then subtract (approx).
      // Create a blurred copy using a basic 3x3 box blur convolution
      let src = tctx.getImageData(0,0,temp.width,temp.height);
      let blurred = boxBlur(src, temp.width, temp.height);
      // sharpen = original*1.8 - blurred*0.8
      let s = src.data, b = blurred.data;
      for (let i=0; i<s.length; i+=4){
        s[i]   = clamp(s[i]*1.8   - b[i]*0.8);
        s[i+1] = clamp(s[i+1]*1.8 - b[i+1]*0.8);
        s[i+2] = clamp(s[i+2]*1.8 - b[i+2]*0.8);
      }
      tctx.putImageData(src,0,0);
    }

    const vctx = canvas.getContext('2d');
    vctx.clearRect(0,0,canvas.width,canvas.height);
    vctx.drawImage(temp,0,0);
  }

  function clamp(v){ return v<0?0:(v>255?255:v); }
  function boxBlur(srcData, w, h){
    const out = new ImageData(w,h);
    const s = srcData.data, d = out.data;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        let r=0,g=0,b=0,a=0, count=0;
        for (let ky=-1; ky<=1; ky++){
          for (let kx=-1; kx<=1; kx++){
            const nx = x+kx, ny = y+ky;
            if (nx>=0 && nx<w && ny>=0 && ny<h){
              const i = (ny*w+nx)*4;
              r+=s[i]; g+=s[i+1]; b+=s[i+2]; a+=s[i+3]; count++;
            }
          }
        }
        const o = (y*w+x)*4;
        d[o] = r/count; d[o+1] = g/count; d[o+2] = b/count; d[o+3] = a/count;
      }
    }
    return out;
  }

  function getCroppedDataURL(){
    if (!crop) return canvas.toDataURL('image/jpeg', quality);
    const out = document.createElement('canvas');
    out.width = Math.round(crop.w);
    out.height = Math.round(crop.h);
    const octx = out.getContext('2d');
    octx.drawImage(canvas, crop.x, crop.y, crop.w, crop.h, 0, 0, out.width, out.height);
    return out.toDataURL('image/jpeg', quality);
  }

  addPageBtn.addEventListener('click', () => {
    const dataUrl = getCroppedDataURL();
    pages.push({ dataUrl, filter: currentFilter });
    renderPages();
    exportPdfBtn.disabled = pages.length === 0;
    clearPageBtn.disabled = pages.length === 0;
  });

  function renderPages(){
    pagesWrap.innerHTML = '';
    pageCount.textContent = pages.length;
    pages.forEach((p, idx) => {
      const d = document.createElement('div');
      d.className = 'thumb';
      d.innerHTML = `<img src="${p.dataUrl}"/><div class="x" title="Hapus">‚úï</div>`;
      d.querySelector('.x').addEventListener('click', () => {
        pages.splice(idx,1);
        renderPages();
        exportPdfBtn.disabled = pages.length === 0;
        clearPageBtn.disabled = pages.length === 0;
      });
      pagesWrap.appendChild(d);
    });
  }

  clearPageBtn.addEventListener('click', () => {
    pages.splice(0, pages.length);
    renderPages();
    exportPdfBtn.disabled = true;
    clearPageBtn.disabled = true;
  });

  exportJpgBtn.addEventListener('click', () => {
    const dataUrl = getCroppedDataURL();
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = `scan-${Date.now()}.jpg`;
    a.click();
  });

  shareBtn.addEventListener('click', async () => {
    try{
      const dataUrl = getCroppedDataURL();
      const res = await fetch(dataUrl);
      const blob = await res.blob();
      const file = new File([blob], `scan-${Date.now()}.jpg`, { type: 'image/jpeg' });
      if (navigator.canShare && navigator.canShare({ files: [file] })){
        await navigator.share({ files: [file], title: 'SmartScan Lite', text: 'Hasil scan' });
      } else {
        alert('Share API tidak tersedia. Gunakan tombol unduh, lalu kirim manual.');
      }
    }catch(e){
      console.error(e);
      alert('Gagal share.');
    }
  });

  exportPdfBtn.addEventListener('click', async () => {
    if (!pages.length) return;
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
    const a4w = 595, a4h = 842, margin = 24;
    for (let i=0; i<pages.length; i++){
      if (i>0) doc.addPage();
      const imgUrl = pages[i].dataUrl;
      const dim = await loadImg(imgUrl);
      let w = a4w - margin*2;
      let h = dim.height * (w / dim.width);
      if (h > a4h - margin*2){ h = a4h - margin*2; w = dim.width * (h / dim.height); }
      const x = (a4w - w)/2, y = (a4h - h)/2;
      doc.addImage(imgUrl, 'JPEG', x, y, w, h);
    }
    doc.save(`scan-${Date.now()}.pdf`);
  });

  function loadImg(src){
    return new Promise(res => { const im = new Image(); im.onload = ()=>res({width:im.width,height:im.height}); im.src=src; });
  }

  // Init
  setUIEnabled(false);
  hint.style.opacity = .8;
})();
      if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js")
        .then(() => console.log("Service Worker registered"))
        .catch(err => console.error("SW registration failed:", err));
    }
</script>
</body>
</html>
